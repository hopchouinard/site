---
/**
 * FileTree component - Interactive file tree navigation for source view
 * Features: collapsible folders, type filtering, hover highlighting
 */
interface Artifact {
  relativePath: string;
  artifactType: string;
  displayGroup: string;
  sizeBytes: number;
  mime: string;
}

interface Props {
  artifacts: Artifact[];
  date: string;
  selectedPath?: string;
}

const { artifacts, date, selectedPath } = Astro.props;

// Build tree structure from flat artifact list
interface TreeNode {
  name: string;
  path: string;
  type: 'file' | 'folder';
  artifact?: Artifact;
  children: TreeNode[];
}

function buildTree(artifacts: Artifact[]): TreeNode[] {
  const root: TreeNode[] = [];
  const nodeMap = new Map<string, TreeNode>();

  artifacts.forEach(artifact => {
    const parts = artifact.relativePath.split('/');
    let currentPath = '';
    let currentLevel = root;

    parts.forEach((part, index) => {
      const isFile = index === parts.length - 1;
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      let node = nodeMap.get(currentPath);

      if (!node) {
        node = {
          name: part,
          path: currentPath,
          type: isFile ? 'file' : 'folder',
          artifact: isFile ? artifact : undefined,
          children: []
        };
        nodeMap.set(currentPath, node);
        currentLevel.push(node);
      }

      if (!isFile) {
        currentLevel = node.children;
      }
    });
  });

  return root;
}

const tree = buildTree(artifacts);

// Get unique artifact types for filters
const artifactTypes = Array.from(new Set(artifacts.map(a => a.artifactType)));
---

<div class="file-tree" data-date={date}>
  <div class="file-tree__filters">
    <button class="filter-chip filter-chip--active" data-filter="all">
      All <span class="filter-chip__count">{artifacts.length}</span>
    </button>
    {artifactTypes.map(type => {
      const count = artifacts.filter(a => a.artifactType === type).length;
      return (
        <button class="filter-chip" data-filter={type}>
          {type.replace(/_/g, ' ')} <span class="filter-chip__count">{count}</span>
        </button>
      );
    })}
  </div>

  <div class="file-tree__search">
    <svg class="file-tree__search-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="11" cy="11" r="8"></circle>
      <path d="m21 21-4.35-4.35"></path>
    </svg>
    <input
      type="text"
      class="file-tree__search-input"
      placeholder="Search files..."
      aria-label="Search files"
    />
  </div>

  <div class="file-tree__content" role="tree" aria-label="Source files">
    {/* Tree will be rendered by client-side script */}
  </div>
</div>

<style>
  .file-tree {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: var(--color-sidebar, #1a1a1a);
    border-right: 1px solid rgba(255, 255, 255, 0.1);
  }

  .file-tree__filters {
    display: flex;
    gap: 0.5rem;
    padding: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-wrap: wrap;
  }

  .filter-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.375rem 0.75rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid transparent;
    border-radius: 0.375rem;
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .filter-chip:hover {
    background: rgba(139, 92, 246, 0.1);
    border-color: rgba(139, 92, 246, 0.3);
    color: #fff;
  }

  .filter-chip--active {
    background: rgba(139, 92, 246, 0.2);
    border-color: rgba(139, 92, 246, 0.5);
    color: #fff;
  }

  .filter-chip__count {
    font-size: 0.7rem;
    opacity: 0.7;
    font-variant-numeric: tabular-nums;
  }

  .file-tree__search {
    position: relative;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .file-tree__search-icon {
    position: absolute;
    left: 1.5rem;
    top: 50%;
    transform: translateY(-50%);
    color: rgba(255, 255, 255, 0.4);
  }

  .file-tree__search-input {
    width: 100%;
    padding: 0.5rem 0.75rem 0.5rem 2.25rem;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 0.375rem;
    color: #fff;
    font-size: 0.875rem;
    font-family: inherit;
  }

  .file-tree__search-input:focus {
    outline: none;
    border-color: #8b5cf6;
    box-shadow: 0 0 0 1px #8b5cf6;
  }

  .file-tree__search-input::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .file-tree__content {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
    font-family: ui-monospace, monospace;
    font-size: 0.875rem;
  }

  .file-tree__content::-webkit-scrollbar {
    width: 8px;
  }

  .file-tree__content::-webkit-scrollbar-track {
    background: transparent;
  }

  .file-tree__content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }

  .file-tree__content::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
</style>

<script define:vars={{ tree, date, selectedPath }}>
  class FileTreeRenderer {
    constructor(container, tree, date, selectedPath) {
      this.container = container;
      this.tree = tree;
      this.date = date;
      this.selectedPath = selectedPath;
      this.expandedFolders = new Set();
      this.currentFilter = 'all';
      this.searchQuery = '';

      this.initialize();
    }

    initialize() {
      this.render();
      this.setupFilters();
      this.setupSearch();

      // Expand path to selected file
      if (this.selectedPath) {
        this.expandToPath(this.selectedPath);
      }
    }

    setupFilters() {
      const filterButtons = document.querySelectorAll('.filter-chip');
      filterButtons.forEach(button => {
        button.addEventListener('click', () => {
          filterButtons.forEach(b => b.classList.remove('filter-chip--active'));
          button.classList.add('filter-chip--active');
          this.currentFilter = button.dataset.filter;
          this.render();
        });
      });
    }

    setupSearch() {
      const searchInput = document.querySelector('.file-tree__search-input');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          this.searchQuery = e.target.value.toLowerCase();
          this.render();
        });
      }
    }

    expandToPath(path) {
      const parts = path.split('/');
      let currentPath = '';

      for (let i = 0; i < parts.length - 1; i++) {
        currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
        this.expandedFolders.add(currentPath);
      }

      this.render();
    }

    matchesFilter(node) {
      if (this.currentFilter === 'all') return true;
      if (node.type === 'folder') {
        // Folder matches if any child matches
        return node.children.some(child => this.matchesFilter(child));
      }
      return node.artifact?.artifactType === this.currentFilter;
    }

    matchesSearch(node) {
      if (!this.searchQuery) return true;
      if (node.name.toLowerCase().includes(this.searchQuery)) return true;
      if (node.type === 'folder') {
        return node.children.some(child => this.matchesSearch(child));
      }
      return false;
    }

    getFileIcon(mime) {
      if (mime?.includes('markdown')) return 'üìÑ';
      if (mime?.includes('json')) return 'üìã';
      if (mime?.includes('yaml')) return 'üìë';
      if (mime?.includes('image')) return 'üñºÔ∏è';
      if (mime?.includes('csv')) return 'üìä';
      return 'üìÑ';
    }

    renderNode(node, level = 0) {
      if (!this.matchesFilter(node) || !this.matchesSearch(node)) {
        return '';
      }

      const indent = level * 1.25;
      const isExpanded = this.expandedFolders.has(node.path);
      const isSelected = node.path === this.selectedPath;

      if (node.type === 'folder') {
        const hasVisibleChildren = node.children.some(child =>
          this.matchesFilter(child) && this.matchesSearch(child)
        );

        if (!hasVisibleChildren && this.searchQuery) {
          return '';
        }

        const html = `
          <div class="tree-node tree-node--folder ${isExpanded ? 'tree-node--expanded' : ''}"
               role="treeitem"
               aria-expanded="${isExpanded}"
               data-path="${node.path}"
               style="padding-left: ${indent}rem">
            <button class="tree-node__toggle" aria-label="Toggle folder">
              <svg class="tree-node__chevron" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
            <span class="tree-node__icon">üìÅ</span>
            <span class="tree-node__label">${node.name}</span>
          </div>
          ${isExpanded ? node.children.map(child => this.renderNode(child, level + 1)).join('') : ''}
        `;
        return html;
      } else {
        const icon = this.getFileIcon(node.artifact?.mime);
        const url = `/daily/${this.date}/source/${encodeURIComponent(node.path)}`;

        return `
          <a href="${url}"
             class="tree-node tree-node--file ${isSelected ? 'tree-node--selected' : ''}"
             role="treeitem"
             data-path="${node.path}"
             style="padding-left: ${indent + 1.5}rem">
            <span class="tree-node__icon">${icon}</span>
            <span class="tree-node__label">${node.name}</span>
          </a>
        `;
      }
    }

    render() {
      const html = this.tree.map(node => this.renderNode(node)).join('');
      this.container.innerHTML = html;

      // Setup folder toggle handlers
      this.container.querySelectorAll('.tree-node--folder').forEach(folder => {
        const toggle = folder.querySelector('.tree-node__toggle');
        if (toggle) {
          toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            const path = folder.dataset.path;
            if (this.expandedFolders.has(path)) {
              this.expandedFolders.delete(path);
            } else {
              this.expandedFolders.add(path);
            }
            this.render();
          });
        }
      });
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      const container = document.querySelector('.file-tree__content');
      if (container) {
        new FileTreeRenderer(container, tree, date, selectedPath);
      }
    });
  } else {
    const container = document.querySelector('.file-tree__content');
    if (container) {
      new FileTreeRenderer(container, tree, date, selectedPath);
    }
  }
</script>

<style is:global>
  .tree-node {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.5rem;
    color: rgba(255, 255, 255, 0.8);
    border-radius: 0.25rem;
    cursor: pointer;
    transition: all 0.15s ease;
    text-decoration: none;
    user-select: none;
  }

  .tree-node:hover {
    background: rgba(139, 92, 246, 0.1);
    box-shadow: 0 0 0 1px #8b5cf6 inset;
    color: #fff;
  }

  .tree-node--selected {
    background: rgba(139, 92, 246, 0.3);
    color: #fff;
  }

  .tree-node__toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1rem;
    height: 1rem;
    padding: 0;
    background: none;
    border: none;
    color: inherit;
    cursor: pointer;
  }

  .tree-node__chevron {
    transition: transform 0.2s ease;
  }

  .tree-node--expanded .tree-node__chevron {
    transform: rotate(90deg);
  }

  .tree-node__icon {
    flex-shrink: 0;
    font-size: 1rem;
    line-height: 1;
  }

  .tree-node__label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.875rem;
  }

  .tree-node--folder .tree-node__label {
    font-weight: 500;
  }
</style>
